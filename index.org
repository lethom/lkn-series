#+TITLE: lkn In A Nutshell
#+AUTHOR: lthms <contact@thomasletan.fr>
#+SETUPFILE: ~/git/org-html-themes/setup/theme-readtheorg.setup

/lkn/ is an experimental framework to write game server. It is written in Elixir
and leverages the OTP framework to build an actor-based implementation of the
Entity-Component-System (ECS) pattern. Whether /lkn/ scales for realistic games
is still an open question, hence the “experimental.” The purpose of the present
document is to give an overview of the [[https://hex.pm/packages/lkn_core][/lkn-core/]] features. You can see it as a
tutorial, and a part of the framework documentation. It is also a literate
programming experiment which leverages Emacs org-mode. In you open this file in
Emacs, ~M-x org-babel-tangle~ will generate the project.

In short, /lkn-core/ is a free and personal interpretation of an
“Elixir-flavour” ECS implementation should look like, on top of a game scene
management machinery.

* /lkn-core/ Explained

** ECS Reinterpretation

What is the Entity-Component-System pattern to begin with? My understanding is
that it is an approach to divide different aspects of a given gameplay into
several unit called systems. Each system takes care of one “function” of the
game. ECS tutorials often list the collision system, the trade system, the
battle system, and so on.

A game scene is populated by so-called Entities. There are various kind of
Entities: players, monsters, obstacles, traps… Systems manipulate Entities: the
collision system decides who moves and who stays put. The battle system dictates
who lives and who dies. Of course, not every Entity can move, or be hurt. A
house can stop a player, but rarely the latter can destroy the former with its
blade.

Components unify how Systems interact with Entities /and/ to determine which
Entities take part in a given System. More precisely, each System declares a
dedicated Component, and if an Entity owns the Component of a System, it means
it takes part in this System.

In Object-Oriented Programming, the ECS pattern allows to use aggregation
instead of inheritance, i.e. components are objects an Entity owns, rather than
classes they inherit from.

Elixir is not an Object-Oriented language, and while /lkn-core/ picks up the
main ideas of the ECS pattern, it implements it in a different way. In short,
Entities are a collection of properties, and Components act as proxies for
Systems to manipulate these properties.

This way, the internal organisation of each kind of Entities can be different
(and match, for instance, their persistent back-end structure), since the
Components abstract that in a unified way for the Systems. Also, two Components
can leverage the same property of a given Entity, meaning they can share
information. For instance, the battle system can access the entity position
managed by the collision system (e.g., to compute a list of potential targets).

#+BEGIN_WARNING
Only one Component should modify a given property of its Entity, to avoid race
conditions and inconsistency. In earliest prototypes of /lkn-core/, this was
enforced by the framework, but this protection was dropped. As a consequence, it
is up to you to be careful.
#+END_WARNING

Also, /lkn-core/ distinguishes between two categories of Entities: Maps, and
Puppets. A Map is a game scene wherein Puppets can evolve. Because a Map is an
Entity, just like a player’s character is, it declares a list of
Components. This list of Components is used by the framework to determine which
Systems it needs to initiate for map in particular. That is, you can have a Map
which owns a Component dedicated to the battle system, and another which does
not.

Systems can act autonomously, e.g. a gravity system has always something to
do. However, a game without players can quickly become boring. Each System
expose an interface the player will use to inject their game choices (move,
attack, defend, etc.). In return, Systems will send back notifications to the
players, so that they can make now choices.

Of course, in this context, a “player” can be a human playing a character, but
it can also be an IA which manipulates a monsters pack. In /lkn-core/, playing
is done through puppets, and therefore, “players” are called Puppeteers.

** Managing Game Scenes

/lkn-core/ is about writing game server, and this means it needs to be able to
manage several game scenes at the same time, sometimes for the very same Map
(e.g. for dungeons). A /lkn-core/ game scene is called an Instance. An Instance
gives life to a Map, by initiating the required Systems.

Instances come and go. When there is no room left for a player, a new instance
must be spawned. Then, when there is no player left inside an Instance, the
latter can die in peace.

The idea is the following: with a Map comes an Instances Pool. When a Puppeteer
wants to join an Instance of this Map, it asks for it to the dedicated Pool,
which returns one Instance (which might have been spawned just for the occasion,
but this is not the Puppeteer concern, and it is totally transparent). The
Puppeteer can then “register” its puppets to its new Instance. When it decides
to leave, it must unregister its puppets, then unregister itself. An Instance
can stay alive for a given amount of time even if it has no Puppeteer left. The
reason is simple: imagine a Map where a rare monster spawns one hour after its
last kill, we do not want to allow players to run into this monster whenever
only by going out and going in the Map.
* The Most Complicated Chat-Server

I suggest we proceed with a concrete example to demonstrate how /lkn-core/ can
be leveraged to write a server.

** Specification

To illustrate /lkn-core/ features, a good example is a chat server. Basically,
we want to be able to:

1. Join the ~#default~ chat-room when we connect to the server
2. Change our nickname
3. Chat (it is a chat-server after all)
3. Join another chat-room, considering that:
   * ~#default~ and ~#spam~ have no chatter limits, but ~#dungeon~ can have at
     most 3 players at the given time
   * ~#dungeon~ stays alive 2 minutes after the last player leaves

** Dependencies

#+NAME: lkn-dependencies
#+BEGIN_SRC elixir
{:lkn_core, "~> 0.4.1"},
{:lkn_prelude, "~> 0.1.2"},
#+END_SRC

#+NAME: other-dependencies
#+BEGIN_SRC elixir
{:uuid, "~> 1.1"},
#+END_SRC

#+BEGIN_SRC elixir :tangle lkn-series/mix.exs :exports none :noweb yes :mkdirp yes
  defmodule Lkn.Series.MixProject do
    use Mix.Project

    def project do
      [ app:              :lkn_series,
        version:          "0.1.0",
        elixir:           "~> 1.6",
        start_permanent:  Mix.env == :prod,
        deps:             deps(),
      ]
    end

    def application do
      [
        extra_applications: [
          :logger,
          :lkn_core,
        ],
      ]
    end

    defp deps do
      [
        <<lkn-dependencies>>
        <<other-dependencies>>
      ]
    end
  end
#+END_SRC
